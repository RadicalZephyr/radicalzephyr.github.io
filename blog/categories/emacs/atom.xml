<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Emacs | Zephyrizing]]></title>
  <link href="http://www.zephyrizing.net/blog/categories/emacs/atom.xml" rel="self"/>
  <link href="http://www.zephyrizing.net/"/>
  <updated>2015-05-15T13:50:42-05:00</updated>
  <id>http://www.zephyrizing.net/</id>
  <author>
    <name><![CDATA[Geoff Shannon]]></name>
    <email><![CDATA[geoffpshannon@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[On Editors and Their Benefits]]></title>
    <link href="http://www.zephyrizing.net/blog/2015/04/16/on-editors-and-their-benefits/"/>
    <updated>2015-04-16T00:58:26-05:00</updated>
    <id>http://www.zephyrizing.net/blog/2015/04/16/on-editors-and-their-benefits</id>
    <content type="html"><![CDATA[I've been using Emacs for about as long as I've been programming. So
that makes it nearly eight years now. I like to think that I've gotten
reasonably competent with it, and somewhat more importantly, I have
customized my emacs to fit my mind like a glove.

I also touch type, but I use the Dvorak keyboard layout. These two
things combine to make it so that I can write programs at a speed
close to how fast I can conceive them. This is important, not because
it means I can code faster than other people, but because it means I
can get the thoughts out of my head fast enough that they don't slip
away.

This was brought into sharp relief for me a few days ago when I did
some pairing with my mentor Zach using his computer. You see, Zach
uses the standard QWERTY layout, and he also uses Vim.

<!--more-->

It seems that the accepted wisdom about pair programming is that it
works best when two people share the same computer, and swap control
of the keyboard back and forth. Some sources even recommend having two
sets of keyboard/mouse to lower the barrier to switching even further.
In the spirit of being open to trying new things I acquiesced to
Zach&#8217;s implicit expectation that I would use his computer with QWERTY
and Vim.

It&#8217;s been a long time since I&#8217;ve seriously attempted to use
QWERTY. When I first taught myself to touch-type in Dvorak I tried to
maintain some proficiency with QWERTY since it is ubiquitous. But I
soon discovered that it was hard to keep both locations for keys in
muscle memory at the same time. And that&#8217;s really where efficient
touch typing requires that knowledge to reside. When you have to
consult your memory for the location of key, you&#8217;ve already lost a lot
of your speed.

Luckily for me, I could keep on typing QWERTY as I always had; that
is, by looking at the keyboard constantly and lifting my fingers high
enough off the keyboard that I could see the letters.

Muscle memory is important to my usage of Emacs too, and it builds
heavily on my Dvorak muscle memory. Emacs has a (deserved) reputation
for having a somewhat absurd number of key bindings. Trying to
remember them directly would be a monumental task. Instead, the most
commonly used key bindings migrate quickly from the realm of conscious
thought to muscle memory. I didn&#8217;t even notice this happening until I
started trying to teach a friend of mine to use Emacs. Some of the
commands that I use, I know only by their location on the keyboard.
Given that I type in Dvorak and the keys are labeled in QWERTY this
means that the actual character I&#8217;m pressing is pretty opaque.

* * *

When is proficiency or familiarity with a tool more important than
other considerations?

First let&#8217;s look a bit at what those other considerations might
be. The first one that comes to mind is that using the same tools as
the team you&#8217;re working on can be pretty important. Or maybe there is
another tool that has much more powerful or focused facilities for the
task/language/domain. Or to reverse that, possibly your tool of choice
simply lacks something that a lot of other tools support. Finally, I
think a really important consideration is whether you are holding on
to your tool(s) of choice out of habit and the comfort they provide.
Let&#8217;s look at some examples of each of these.

A few years ago I was hired as an intern at Sage Bionetworks, a small
bio-tech start-up in Seattle. They happen to be an all Java shop,
and the standard editing environment there is Eclipse. At the time, I
was much less familiar with Emacs, I had never even opened Eclipse and
I didn&#8217;t know any Java.

I spent my first few days getting through the administrative details
of starting a new job. But pretty quickly I got to the point where I
needed to setup my new computer for doing development on the Sage web
platform. They had a wiki, with several different pages on the
bootstrapping process for the various different aspects of the
process. A significant portion of it was focused on getting your
Eclipse installation setup correctly, with all the right plugins and
such.

Being totally in love with Emacs at that time, I determined that I was
going to figure out how to setup Emacs as a kick-ass Java editing
environment. My mentor was grudgingly amenable to this plan of
action. I struggled with that problem for a few days, until my mentor
came back and strongly suggested that I use Eclipse. His rationale was
essentially that this was the tool that the whole team had
standardized on. Since no one else really used the command line tools
to build or test the product I would be largely on my own in getting
things to work.

I gave in, and learned to use Eclipse. I made it bearable by
installing a plugin that simulated Emacs key bindings. I learned there
were some nice things about Eclipse - the automatic versioning, the
Java refactoring tools. But I also found it to generally be a vastly
inferior tool. While Eclipse has an extensive ecosystem of plugins and
add-ons, installing them is a nightmare of clicking through GUI menus
and needing to restart possibly several times. It is also highly
customizable, with good support for key maps and visual
modifications. However, neither your personally installed add-ins nor
your configurations can be saved in a reasonable way, and there is (as
far as I know) no way to automate the setup process. So every time you
move to a new development machine, you need to go through the same
process. Or, more likely, go through a very *similar* process, and
end up with a subtly different dev environment.

But I did get the benefit of being able to get the advice of the other
devs on the team when something wasn&#8217;t working with my build. This
turned out to be critical since the process of getting a working (and
repeatable) build of their software was a highly non-trivial one.

When I was working with Zach last week and ended up using Vim with
QWERTY, he said something to me that reminded of my mentor&#8217;s words at
Sage. He said that a lot of people at 8th Light use Vim, and that if I
want to do a lot of pairing with people it will probably be to my
benefit to learn how to use Vim at least a little bit.

This makes more sense in an environment where pairing is actively
practiced, but the general idea behind it is basically the prospect of
being able to sit down at someone else&#8217;s computer and use it for
development at a reasonable level. I&#8217;m not sure that I agree with this
philosophy though.

One place where being able to use any given computer is key is as a
sysadmin. My college&#8217;s CS department started participating in a
national competition during my second year, the Collegiate Cyber
Defense Competition or CCDC. The competition itself basically places
several teams of students in the role of a new system administration
team for some large corporation. The system is potentially in disarray
after a poorly documented transition from a previous team and the
students task is to secure the systems while maintaining a given level
of availability for one or more different services (such as email,
databases, servers, etc.).

I was very interested in participating in the club that was preparing
for the competition because they were learning both defensive and
offensive computer security skills. But I found it difficult to work
in the context of system&#8217;s administration because I couldn&#8217;t have my
environment setup just how I wanted it. Particularly during the
competition itself, there would be no time to try and install Emacs
(which is both large in footprint and memory usage and requires a ton
of dependencies), or switch the terminal at the computer I was using
to Dvorak. Thus I found that two choices I had made years before had
effectively precluded my participation in the CCDC.

Interestingly, my choice to learn the Dvorak layout is actually what
pushed me into learning Emacs. I had just gotten to the point of
actual touch-typing with Dvorak when I decided it was time to switch
from using PythonWin to a &#8220;real programmer&#8217;s editor.&#8221; Based on what I
had been reading on the internet, that choice seemed clear: it had to
be Vim.

But I was stalled almost immediately. Vim uses the letters &#8216;h&#8217;, &#8216;j&#8217;,
&#8216;k&#8217;, and &#8216;l&#8217; for text navigation, so you don&#8217;t need to move your hand
to the arrow keys.  This is convenient for usage under QWERTY, all
four keys are on the home row and are easily accessible - without
stretching - to your right hand. But on Dvorak they are all over the
keyboard, and there is no mnemonic for telling which key does
what.

I struggled with Vim for a few days, trying to learn how I could remap
the movement keys to the same location under Dvorak as they are in
QWERTY. But I was unable to find a solution and the prospect of the
cascading key remappings was enough to drive me to look at Emacs.  By
contrast with Vim, most of the keys in Emacs have some kind of
mnemonic association. Moving forward a character is `ctrl f` and back
is `ctrl b`. Down one line is `ctrl n` and up is `ctrl p` for next and
previous. Not only that, but part of the very philosophy of Emacs is
easy customization, up to and including remapping every key on your
keyboard to do something different. More importantly, that philosophy
of customization is embedded in the Emacs community.

The seemingly simple choice of learning to type in Dvorak turned out
to be a key decision in my life as a programmer. It cut off certain
possibilities like learning to use Vim, and presents certain
challenges for pair programming, particularly in the quick
back-and-forth style where two people use the same computer. I have
also found that using Emacs appears to be the less common of the two,
and this is also limiting and isolating to some degree.

Here&#8217;s the thing though, I *like* using Emacs; and typing in Dvorak
feels good to my fingers. So I&#8217;m a little bit stuck. I want to be
agreeable and able to collaborate and pair program with others
easily. But I also really like the tools that I use. They fit me. So
what do I do?

One possibility is to use more tools to overcome some of my
difficulties with pairing. Specifically, using a lightweight version
control system (like git) and a free code hosting site (like, say,
Github) you can arrange a style of pairing where two people work on
the same code, but each using their own device and tools and
setup. Pairing is the same during the actual coding process with
whatever Driver/Navigator or other dynamic you want to use. The
difference comes when you swap. Instead of simply sliding the keyboard
across to your partner, you commit, and push to your central
repository. Your partner then pulls down the latest code and starts
working on their machine. This is certainly a bit more work than just
handing off the keyboard, so it may not be suitable to very rapid
hand-offs. But I haven&#8217;t found it to be overly onerous so far.

Another solution would be for me to maintain some skill at QWERTY and
Vim specifically for facilitating pairing. While more work for me
personally, it has the benefit of not requiring a new pairing
workflow. But this idea worries me a bit.

The human brain is [amazingly flexible][neuroplas]. My favorite
personal example of this is related to video games and how we control
them. Every first-person style game has at least one key setting in
the control options: whether the way you look upwards is by moving the
mouse or tilting the control stick upwards (usually known as &#8220;default&#8221;
or &#8220;normal&#8221;), or whether this mapping is &#8220;inverted&#8221; i.e. tilting up
looks down and tilting down looks up. My best friend and I have played
a lot of Halo together in our day. For a long time one of our favorite
pastimes was playing through Halo 2 levels on Legendary difficulty,
often with skulls active. Here&#8217;s the thing though: he plays default,
and I play inverted.

[neuroplas]: https://en.wikipedia.org/wiki/Neuroplasticity

Under most circumstances this doesn&#8217;t matter. If we&#8217;re playing
cooperatively it doesn&#8217;t matter because we both have our own
controller and thus our own setting. It only becomes an issue when we
are handing a controller back and forth. But boy is it a problem
then. Invariably we both forget to switch back at the hand-off and
there ensues a brief period of confusion and panic when the game
character doesn&#8217;t respond as our brain is wired to think it
should. What&#8217;s really fascinating though is how quickly my brain
starts to retrain itself.

I&#8217;ve been playing games on inverted for years, possibly decades at
this point. As such you would think that my brain is very much
hardwired to expect that when I tilt the stick up, the view will move
down. And this is true. But sometimes, for one reason or another I&#8217;ll
end up playing for a short time on the default setting. What happens
is remarkable and incredibly frustrating. If I focus on trying to
remember that up means up and down means down, I can usually get to a
level that is usable - at least when I pay full attention. But as soon
as something intense happens like a bad guy jumping out from behind a
bush, my reflexes revert to inverted settings. Even more interestingly
though, when I inevitably switch my control scheme back to inverted I
am unable to fully shed the tendency towards trying to play with
default look controls.

Back to keyboard layouts and editors. In short, I&#8217;m concerned that an
attempt to learn how to use QWERTY again and to memorize Vim keyboard
shortcuts will seriously undermine my ability to use Emacs effectively.

On the other hand, maybe this is just what I need. I&#8217;m also currently
trying to learn how to do Test Driven Development (TDD) and I&#8217;m
finding that a lot of the thought-habits I have around programming are
actually detrimental to doing TDD. Maybe breaking out of my
comfortable Emacs environment and using a new keyboard layout will
help me get into a totally new frame of mind and let me TDD more
effectively.

I think there is another reason to embrace the idea of learning a new
set of tools at this time though. A large part of the reason that I
wanted to do this apprenticeship with 8th Light was to learn. Learning
from others always requires some humility; at the very least you have
to be able to admit that there are things that you do not know. This
is difficult for me. But possibly, intentionally cultivating
[Shoshin][shoshin] or &#8220;beginner&#8217;s mind&#8221; regarding my most basic level
of programming - how I edit my source code - will help me do it at all
levels.

> In the beginner&#8217;s mind there are many possibilities, in the expert&#8217;s
> mind there are few. - Shunryu Suzuki

[shoshin]: https://en.wikipedia.org/wiki/Shoshin
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Playing With Org-mode]]></title>
    <link href="http://www.zephyrizing.net/blog/2014/10/27/playing-with-org-mode/"/>
    <updated>2014-10-27T17:30:05-05:00</updated>
    <id>http://www.zephyrizing.net/blog/2014/10/27/playing-with-org-mode</id>
    <content type="html"><![CDATA[So, as a way to procrastinate on actually starting to write/practice
my lightning talk for Thursday, I decided that I absolutely wanted to
make a slide show using the [org-html-slideshow], a pretty neat piece
of Clojurescript written by those smart guys at
~~Relevance~~ Cognitect.

[org-html-slideshow]: https://github.com/relevance/org-html-slideshow

Basically, it lets you take an outline/document written in [Org-mode]
(another really cool piece of software!) and put some small
annotations in it to delimit your "slides" and then you have a
document that can be viewed as either a slideshow, or a web page. It's
harder to explain in words than it is to observe, so here's the
[example page](/demos/example.html) from their github repo, and the
[org-mode document](/demos/example.org) that produced that page.

[Org-mode]: http://orgmode.org/

<!--more-->

Now that is pretty neat. However, the workflow needed to create one of
these is sort of a pain. From the documentation on the project page,
you&#8217;re expected to create a one-off web site that has the contents of
this production folder available and then manually generate the
html document from the org-mode source. Ick.

My blog is made with [Jekyll], which is a static site generator. None
of my posts are actually written in html, instead I write them in
[Markdown], and then Jekyll handling converts the markdown into
html. When it does this I can also cause it to be inserted into a page
template (i.e. layout). The upshot is, I can create a static site but
not have to duplicate all of the code to have a common set of header
info, navigation toolbar, nifty sidebar etc. Because only the unique
things are specified in each document, and the general boilerplate is
automatically included for me by Jekyll.

So if I&#8217;m generating html from markdown automatically with Jekyll it
feels sort of wrong to be generating html manually with an interactive
emacs command and then committing this generated html into my git
repo. It would be so much nicer if I could just get Jekyll to invoke
emacs as the translator for turning `.org` files into `.html` files.

[Jekyll]: http://jekyllrb.com/
[Markdown]: http://daringfireball.net/projects/markdown/syntax

Well, pursuing that line of thought today I worked with
[Waldemar Quevedo]. He showed me his incredible org-based workflow for
everything (he also gave an awesome lightning talk on it the first
week of Hacker School!). While it looks really cool, it&#8217;s sort
heavy-weight for what I want to do. Frankly, I&#8217;m really comfortable
writing markdown, so I&#8217;ll probably continue to write most of my posts
in it. But org-html-slideshow is exciting enough that I&#8217;d be willing
to write my presentations in Org-mode so I can utilize it.

[Waldemar Quevedo]: https://github.com/wallyqs

I won&#8217;t attempt to explain Wally&#8217;s setup, but he&#8217;s got some
[pretty][pretty] [cool][cool] [stuff][stuff] going on. In essence
though, he uses a ruby gem to parse the org syntax and transform it
into markdown. As of this writing though, it doesn&#8217;t support the tags
feature that org-html-slideshow depends on for it&#8217;s functionality.

[pretty]: https://github.com/wallyqs/org-ruby
[cool]: https://github.com/eggcaker/jekyll-org
[stuff]: https://github.com/punchagan/org-hyde

While showing Wally the slideshow thing got him excited to try and
integrate it into his workflow, I started poking around and looking at
how to integrate it into my site. The solution I decided on was to
make `.org` files a generic member of the Jekyll source files. This
means that they&#8217;ll still use a YAML frontmatter to mark that they need
to be transformed. This means that I need some way to transform a body
of org text into just the html content that it represents. Normally
when you generate an html page from org-mode, you get a complete html
page, `html`, `body` tags and all. What I needed was a way to invoke
the org->html transformation using the Elisp code in org-mode from
Jekyll.

With Wally&#8217;s help, I was able to get this far towards that goal. This
is the elisp that will continuously read from the minibuffer until an
error occurs, and then transform that text using the org->html backend,
and finally print out the generated html.


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='common-lisp'><span class='line'><span class="p">(</span><span class="k">progn</span>
</span><span class='line'>  <span class="p">(</span><span class="nb">require</span> <span class="ss">&#39;org</span><span class="p">)</span>
</span><span class='line'>  <span class="p">(</span><span class="k">progn</span>
</span><span class='line'>    <span class="p">(</span><span class="nv">condition-case</span> <span class="no">nil</span>
</span><span class='line'>        <span class="p">(</span><span class="nv">while</span> <span class="no">t</span>
</span><span class='line'>          <span class="p">(</span><span class="nv">insert</span> <span class="p">(</span><span class="nv">read-string</span> <span class="s">&quot;&quot;</span><span class="p">)</span> <span class="s">&quot;\n&quot;</span><span class="p">))</span>
</span><span class='line'>      <span class="p">(</span><span class="nb">error</span> <span class="no">nil</span><span class="p">))</span>
</span><span class='line'>    <span class="p">(</span><span class="nv">set-buffer</span>
</span><span class='line'>     <span class="p">(</span><span class="nv">org-export-to-buffer</span> <span class="ss">&#39;html</span> <span class="s">&quot;*Org HTML Export*&quot;</span>
</span><span class='line'>       <span class="no">nil</span> <span class="no">nil</span> <span class="no">nil</span> <span class="no">t</span> <span class="no">nil</span>
</span><span class='line'>       <span class="p">(</span><span class="k">lambda</span> <span class="p">()</span> <span class="no">t</span><span class="p">)))</span>
</span><span class='line'>       <span class="p">(</span><span class="nv">message</span> <span class="s">&quot;%s&quot;</span> <span class="p">(</span><span class="nv">buffer-string</span><span class="p">))))</span>
</span></code></pre></td></tr></table></div></figure>

And this is how you invoke the transformation of a file from org to
html. The `$emacs` is because I use [Emacs for Mac OSX] which means
that my emacs executable is buried inside of a mac `.app` file/folder
thing. Pipe a file into this script and if it&#8217;s valid org syntax,
you&#8217;ll get the corresponding html.

[Emacs for Mac OSX]: http://emacsformacosx.com/

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>tail -n+4 hello.org <span class="p">|</span> <span class="nv">$emacs</span> --batch --eval <span class="s2">&quot;(progn (require &#39;org) (progn (condition-case nil (while t (insert (read-string \&quot;\&quot;) \&quot;\\n\&quot;)) (error nil)) (set-buffer (org-export-to-buffer &#39;html \&quot;*Org HTML Export*\&quot; nil nil nil t nil (lambda () t))) (message \&quot;%s\&quot; (buffer-string))))&quot;</span>
</span></code></pre></td></tr></table></div></figure>

Now the only thing that&#8217;s left is to write a Jekyll plugin to do this
invocation to produce the final output. ~~This is what I came up with
as a first attempt. Of course, it doesn&#8217;t actually work for me,
because of the dumb location of my emacs executable&#8230; Oh well, that&#8217;s
for tomorrow.~~

__Edit 10/28__: So I spent the first half of today fixing this up.
Turned out to be more involved than I suspected. I had to evolve the
emacs lisp command enough that I actually made a separate git repo for
it. I fixed the problem of locating a proper emacs binary by deferring
to an appropriately named environment variable. I originally
implemented this shortcut by letting the user specify the location of
emacs in their `_config.yml`. But then I realized, this is not a
configuration that happens per-site, it&#8217;s per machine so the site
config file is totally inappropriate. It&#8217;s kind of annoying though
since if I forget to specify this environment variable then my site
generation won&#8217;t work&#8230;

Anyhow, it works and as proof I made a version of the example
presentation that is [generated by my plugin][example-plugin], not by
hand. You don&#8217;t have to take my word for it, but you will have to look
at the [git repository for this site](zephyrizing).

[example-plugin]: /demos/example-plugin.html
[zephyrizing]: https://github.com/RadicalZephyr/radicalzephyr.github.io/tree/master/demos

And here is the final code for my org-mode plugin generator:

<figure class='code'><figcaption><span>&#8220;Org Converter&#8221;  (org_converter.rb)</span> <a href='//../plugins/org_converter.rb'>download</a></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="c1"># A generator that uses a emacs invoked in batch mode to process</span>
</span><span class='line'><span class="c1"># org-mode files into html</span>
</span><span class='line'>
</span><span class='line'><span class="nb">require</span> <span class="s1">&#39;open3&#39;</span>
</span><span class='line'>
</span><span class='line'><span class="k">module</span> <span class="nn">Jekyll</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">class</span> <span class="nc">OrgModeConverter</span> <span class="o">&lt;</span> <span class="no">Converter</span>
</span><span class='line'>    <span class="n">safe</span> <span class="kp">false</span>
</span><span class='line'>    <span class="n">priority</span> <span class="ss">:low</span>
</span><span class='line'>
</span><span class='line'>    <span class="vc">@@emacs_org_html_cmd</span> <span class="o">=</span> <span class="s2">&quot;(progn (require (quote org)) (setq font-lock-mode t) (setq org-html-head-include-default-style nil) (setq org-html-head-include-scripts nil) (condition-case nil (while t (insert (read-string </span><span class="se">\&quot;\&quot;</span><span class="s2">) </span><span class="se">\&quot;\n\&quot;</span><span class="s2">)) (error nil)) (set-buffer (org-export-to-buffer (quote html) </span><span class="se">\&quot;</span><span class="s2">*Org HTML Export*</span><span class="se">\&quot;</span><span class="s2"> nil nil nil t nil (lambda nil t))) (send-string-to-terminal (buffer-string) nil))&quot;</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">def</span> <span class="nf">matches</span><span class="p">(</span><span class="n">ext</span><span class="p">)</span>
</span><span class='line'>      <span class="n">ext</span> <span class="o">=~</span> <span class="sr">/^\.org$/i</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">def</span> <span class="nf">output_ext</span><span class="p">(</span><span class="n">ext</span><span class="p">)</span>
</span><span class='line'>      <span class="s2">&quot;.html&quot;</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">def</span> <span class="nf">convert</span><span class="p">(</span><span class="n">content</span><span class="p">)</span>
</span><span class='line'>      <span class="n">emacs_path</span> <span class="o">=</span> <span class="k">if</span> <span class="no">ENV</span><span class="o">.</span><span class="n">has_key?</span><span class="p">(</span><span class="s2">&quot;EMACS&quot;</span><span class="p">)</span>
</span><span class='line'>                     <span class="no">ENV</span><span class="o">[</span><span class="s2">&quot;EMACS&quot;</span><span class="o">]</span>
</span><span class='line'>                   <span class="k">else</span>
</span><span class='line'>                     <span class="sb">`which emacs`</span>
</span><span class='line'>                   <span class="k">end</span>
</span><span class='line'>
</span><span class='line'>      <span class="k">if</span> <span class="n">emacs_path</span><span class="o">.</span><span class="n">empty?</span>
</span><span class='line'>        <span class="nb">puts</span> <span class="s2">&quot;Could not find an emacs executable.&quot;</span>
</span><span class='line'>      <span class="k">else</span>
</span><span class='line'>        <span class="n">out</span><span class="p">,</span> <span class="n">status</span> <span class="o">=</span> <span class="no">Open3</span><span class="o">.</span><span class="n">capture2</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">#{</span><span class="n">emacs_path</span><span class="si">}</span><span class="s2"> --batch --eval &quot;</span> <span class="o">+</span>
</span><span class='line'>                                     <span class="s2">&quot;</span><span class="si">#{</span><span class="vc">@@emacs_org_html_cmd</span><span class="o">.</span><span class="n">inspect</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
</span><span class='line'>                                     <span class="ss">:stdin_data</span><span class="o">=&gt;</span><span class="n">content</span><span class="p">)</span>
</span><span class='line'>        <span class="n">out</span> <span class="k">unless</span> <span class="n">status</span> <span class="o">!=</span> <span class="mi">0</span>
</span><span class='line'>      <span class="k">end</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>
]]></content>
  </entry>
  
</feed>
