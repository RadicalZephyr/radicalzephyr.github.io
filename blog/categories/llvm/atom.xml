<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Llvm | Zephyrizing]]></title>
  <link href="http://www.zephyrizing.net/blog/categories/llvm/atom.xml" rel="self"/>
  <link href="http://www.zephyrizing.net/"/>
  <updated>2015-05-13T10:55:21-05:00</updated>
  <id>http://www.zephyrizing.net/</id>
  <author>
    <name><![CDATA[Geoff Shannon]]></name>
    <email><![CDATA[geoffpshannon@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Getting Started With LLVM and OCaml on OS&nbsp;X]]></title>
    <link href="http://www.zephyrizing.net/blog/2014/12/14/getting-started-with-llvm-and-ocaml-on-os-x/"/>
    <updated>2014-12-14T00:15:16-06:00</updated>
    <id>http://www.zephyrizing.net/blog/2014/12/14/getting-started-with-llvm-and-ocaml-on-os-x</id>
    <content type="html"><![CDATA[I [wrote recently][llvm-mac] about my (second) experience trying to
get started using LLVM on my Macbook. Shortly after that, I became
interested in combining my interest in LLVM with my interest OCaml. As
it turns out, this was a much easier task than I anticipated.

[llvm-mac]: /blog/2014/11/19/getting-started-with-llvm-on-os-x/

<!--more-->

Since my whole experiment with Vagrant was so successful for using
the C++ LLVM libraries, I immediately started doing the same thing for
my OCaml experiments. I created a `Vagrantfile` and started trying to
write a bash script to correctly provision an Ubuntu instance with the
requirements for the OCaml LLVM bindings.

I was stalled fairly quickly by the fact that the version of
[OPAM][opam] in the Ubuntu apt repositories is somewhat old.  Old
enough that it doesn&#8217;t want to talk to the official OPAM servers for
package updates. So I futzed and fiddled a bit, and looked around for
alternate ways to install OCaml.

Eventually I got it figured out, and started trying to install the
OCaml bindings for LLVM. It didn&#8217;t go well. The compilation of the
llvm opam package errored almost immediately. But while I was looking
through the error messages, I noticed something interesting. The
errors were related to nonexistent paths, and the paths that the
package was expecting all started with `/usr/local/Cellar`. For the
non brew-savvy, this is the default location that [Homebrew][brew]
uses for all it&#8217;s installations.

[brew]: http://brew.sh/

I knew that homebrew had an LLVM package because of my C++
meanderings. The error messages from OPAM on Ubuntu made me think that
the OCaml LLVM package was actually expecting to be run on a Mac, or
at least to work with a `brew install`ed LLVM.

So I gave it a shot. I cleaned out and re-installed my LLVM installation
with `brew rm llvm && brew install llvm`. And then I simply ran `opam
install llvm`. As far as I remember (it was a couple weeks ago now ;),
everything went off without a hitch.

<How was I able to validate the installation? Looked at Kaleidoscope
tutorial?>

Finally, I wanted to be able to use the top-level to explore the LLVM
API, but that didn&#8217;t appear to work right away. After some googling, I
found an answer on Stack Overflow (of course!) that said I had to
compile a custom version of utop with the LLVM libraries linked in.

I did that <describe it!! got to refigure out how I did that though>,
and then was able to get the wonderful utop completion stuff to work
with the totally unfamiliar LLVM bindings in OCaml.

Of course, then I needed to implement a [language to actually compile
with LLVM][ocaml-postfix]. And of course I still haven&#8217;t actually done
anything with LLVM&#8230;

[ocaml-postfix]: https://github.com/RadicalZephyr/postfix-ocaml
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Getting Started With LLVM on OS&nbsp;X]]></title>
    <link href="http://www.zephyrizing.net/blog/2014/11/19/getting-started-with-llvm-on-os-x/"/>
    <updated>2014-11-19T02:31:00-06:00</updated>
    <id>http://www.zephyrizing.net/blog/2014/11/19/getting-started-with-llvm-on-os-x</id>
    <content type="html"><![CDATA[A few weeks ago, I decided that one of the things I wanted to tackle
during my time at Hacker School was getting familiar with the LLVM
project. To that end, myself and several other Hacker Schoolers formed
an informal group to work through the official
[LLVM Kaleidoscope][llvmkal] tutorial. We made reasonable progress at
first, but as soon as we actually had to start dealing with the LLVM
tools, I started encountering problems.

[llvmkal]: http://llvm.org/releases/3.5.0/docs/tutorial/index.html

Long story short, I ended up getting frustrated with the state of the
documentation surrounding LLVM and moving on to working on other less
upsetting projects. This last weekend though I ended up getting back
into it. I tried two different approaches.

<!--more-->


First, I decided to use a Vagrant supported VM to do my LLVM
setups. This was for two reasons: the fact that I do my development on
a Mac running OS X seems to be problematic when trying to install LLVM
in a global manner. This is because *some* of the LLVM tools (like
Clang) make up the default build environment on OS X. But the toolset is
insufficient if you actually want to build languages with LLVM, and
the presence of these libraries makes it&#8230; complicated to try and
install a more complete version. As Homebrew says when you try to
install LLVM via `brew install llvm`:

> Mac OS X already provides this software and installing another
> version in parallel can cause all kinds of trouble.

This is essentially the problem that I ran into a couple weeks ago
that caused me to give up on working with LLVM. This time however, I
had the insight that I wasn&#8217;t solely limited to the physical machine
that I had an the one operating system I have the space to install on
it. By using [Vagrant] I could pretty trivially have a working Ubuntu
environment to use as my development platform for working with LLVM.

[Vagrant]: https://www.vagrantup.com/

So that&#8217;s what [I did][vagrantllvm]. The most interesting thing about
that repository is how I ended up provisioning my Vagrant
VM. To quote briefly from the [Wikipedia Article][wikiprov]:

> &#8230; provisioning is a set of actions to prepare a server with
> appropriate systems, data and software, and make it ready&#8230;

[vagrantllvm]: https://github.com/RadicalZephyr/postfix-llvm
[wikiprov]: https://en.wikipedia.org/wiki/Provisioning#Server_provisioning

The provisioning is done via shell scripts (that&#8217;s not the interesting
part!), but instead of using `apt-get` to install all the software
that I required I mostly had to build them from scratch. But let&#8217;s go
through the story end to end.

First off, I did try to install all the software via `apt-get`. There
was some confusion for me about which version of LLVM to install. From
the reading I&#8217;d done on the [LLVM site] previously I thought that
since 3.5 has been officially released it would be considered the
stable version. However, when you install LLVM 3.5 via `apt` (with
`sudo apt-get install llvm-3.5`) the binaries don&#8217;t seem to end up
getting installed on a path location. Or rather, they are on path, but
the names are all suffixed with `-3.5`.

[LLVM]: http://llvm.org/releases

This wasn&#8217;t really what I wanted, so I also tried installing the 3.4
packages which it turns out are also the default set of packages
installed if you `apt-get install llvm`. This got the right names for
the tools onto my path, so step one check. So much easier to install
than with Homebrew! Well, to install and make sure that it was available
to me anyhow.

Then, since I was going to be doing `C++` development, I wanted to use
[CMake] as my build generator. If you&#8217;ve never used CMake but you do
`C/C++` development I&#8217;d highly recommend checking it out. It allows
you to specify your build process at a very high level.  As a bonus,
it can then generate the files to process that build with [several][1]
[different][2] [kinds][3] of actual [build systems][4]. It&#8217;s way more
convenient than writing your own `Makefiles` and much more modern than
the whole [autoconf] system (which I can&#8217;t say much about, I&#8217;ve never
learned it).

[CMake]: http://www.cmake.org/
[1]: http://www.gnu.org/software/make/
[2]: https://eclipse.org/
[3]: http://msdn.microsoft.com/en-us/vstudio/aa718325.aspx
[4]: http://www.cmake.org/cmake/help/v3.0/manual/cmake-generators.7.html#id4
[autoconf]: https://www.gnu.org/software/autoconf/

Anyhow, CMake has another handy benefit. It has a system for
[finding your dependencies][findpkg]. Not like over the internet like
[some build systems][maven], but still it&#8217;s better than the basic
situation in C. Since CMake has actually been around for a while there
are many standard open source projects that provide the mechanics for
finding their libraries with CMake, including - handily enough - the
LLVM project.

[findpkg]: http://www.cmake.org/Wiki/CMake:How_To_Find_Libraries
[maven]: http://stackoverflow.com/questions/1541771/using-maven-for-c-c-projects

One requirement of this system is that a &#8220;module file&#8221; be somewhere on
the CMake `modules-path`. For packages that support it, this should
happen when the package is installed and the locations of the critical
library and header files are actually known. Only problem is that the
CMake packages available in the Ubuntu repositories don&#8217;t actually do
this. Turns out there was a [bug report] early in 2014 describing the
issue. Then a long back and forth with the package maintainer (I
think) and many cases of &#8220;Hey, it should be fixed now!&#8221;, followed by a
response of &#8220;No, it actually still doesn&#8217;t work&#8230;&#8221;

[bug report]: https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=735592

Then I found the LLVM `apt` [nightly builds page][llvmapt] which
possibly answers why LLVM 3.4 is still the default package on Ubuntu,
since the LLVM project considers 3.4 to be &#8220;stable&#8221; and 3.5 is the
&#8220;qualification branch.&#8221; This `apt` repository seemed like a good bet
for finding an LLVM package that would properly install the necessary
CMake files, but alas, I had no such luck.

[llvmapt]: http://llvm.org/apt/

So instead I built LLVM from scratch. This is both easier and harder
than it sounds. Building LLVM from source is a very automated process,
and the parts that aren&#8217;t automatic by default (like downloading,
checking file signatures and unpacking archives) are highly
automatable. The painful part is that VM&#8217;s are always slower than a
natively installed OS. And my poor Macbook Air takes about 45 minutes
to do a full LLVM build under the native OS X. So basically once I got
everything setup I let the LLVM build run and stopped thinking about
it except to check on it every few hours.

I had quite a few build failures mostly related to what seem
like out of memory errors in GCC. Sometimes just restarting the
compilation helped, but I also restarted Vagrant VM and gave it a full
2GB of memory which helped a lot.

Once the install finished though CMake was able to find it
immediately. As pointed out earlier, the code is up on Github. I was
surprised to discover that there is no Vagrant VM that exists for
doing LLVM development, so that&#8217;s going to go on my list of
projects. Ideally, that **won&#8217;t** involve building LLVM from source in
the provisioning stage, because of the computational issues with
VM&#8217;s. It might be an interesting excuse to learn how to build .deb
packages and make a PPA with a CMake that properly installs the
`FindLLVM.cmake` files&#8230;
]]></content>
  </entry>
  
</feed>
