---
layout: presentation
title: Reimplementing .gitignore in 12 lines of bash
---

* What is a .gitignore file                                           :slide:

** A simple shell style syntax (globbing) for specifying files

** Some examples:

#+begin_src
# Specific filenames
.emacs.desktop
.emacs.desktop.lock

# Directories
auto/

# Wildcard Patterns
*.gch
*.beam
*.com
*.class

... some others
#+end_src

To see more check out https://github.com/github/gitignore


** Why did I want it?                                                 :slide:

*** A project of mine called Hermit

- A dotfiles configuration management assistant
- https://github.com/RadicalZephyr/hermit

*** Linking Files                                                     :slide:

- Need to be able to setup symbolic links
- But it would be nice to be able to ignore (not link) certain files

* How is it implemented?

** Back up and decompose the problem

- git-ls-files: print out all non-ignored files
- Okay, how do I implement *that*?

*** Notes                                                              :note:

First, let's decompose the problem a bit more. Instead of worrying
about how to selectively link most files in a directory tree into the
corresponding tree under a different root, let's transform this into
something that's more approachable.

My initial attempt to re-use git's implementation led me to find out
about the command `git-ls-files` which basically does an `ls` on your
git repository printing out only files that have *not* been ignored.

This seems like a useful way to break up the problem.

** The Implementation

#+begin_src
{
    find . -type f -o -type d -name .git -prune

    find . -type f -name .hignore
    {
        find -X . -type f -name .hignore | xargs -n1 dirname |
        while read dir
        do
            sed 's|^|'"$dir/"'|' "$dir"/.hignore
        done
    } | xargs -n1 find . -type d -name .git -prune -o -type f -path

} | sort | uniq -u | cut -c3-
#+end_src

** Wat?                                                               :slide:

** The more readable version                                          :slide:

#+begin_src
{
    # Print the list of all files, but don't recurse into the .git folder
    find . -type f -o -type d -name .git -prune

    # Print out all .hignore files a second time so we ignore them
    find . -type f -name .hignore

    # Concatenate a listing of all .hignore files, with the path to the
    # ignore file it came from prefixed to each pattern
    {
        # Process all directories with a .hignore file
        find -X . -type f -name .hignore | xargs -n1 dirname |
        while read dir
        do
            # Prefix the contents of each .hignore file with the path
            # to the file it came from
            sed 's|^|'"$dir/"'|' "$dir"/.hignore
        done

        # And finally, print out all of the files that match each of the
        # patterns from all .hignore files. Using find and the -path
        # option allows us to respect the relative placement of each
        # pattern in the directory hiearchy.
    } | xargs -n1 find . -type d -name .git -prune -o -type f -path

    # Now, sort and then print only the unique lines.  This works
    # because anything that matched an ignored pattern was printed
    # once by the first find, and then once by the ignore find, thus
    # duplicating it. Also, remove the leading ./
} | sort | uniq -u | cut -c3-
#+end_src

** Let's take that step by step

#+OPTIONS: num:nil toc:nil tags:t

#+TAGS: slide(s) note(n)
