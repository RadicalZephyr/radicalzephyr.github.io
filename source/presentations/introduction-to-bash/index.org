---
layout: presentation
title: Introduction to Bash Scripting
---

* A.K.A. - How To Use The Command-Line Like A Pro

** Unix Tools Philosophy                                              :slide:

- Files and plain-text
- Library of composable tools
- Arguments
- Standard Input/Output/Error
- Pipes
- The Environment

*** Everything is a (plain-text) file                                 :slide:

- Very file-oriented
- Characters are characters

- As opposed to office suites
  - Binary file format (also proprietary)
  - Need specialized code to read/write in the correct format
  - Has "export" functions to transform it to different formats


*** Library of Tools                                                  :slide:

Focus on a few at a time.  Empahasize incremental learning.  It's a
large toolbox and potentially overwhelming.  Take away is that adding
even one tool is a valuable outcome.

- show a web page here of list of many different unix tools


*** Arguments                                                         :slide:

- Two types
  - Switches (i.e. ~-c~ or ~--count~)
  - Other

- Conventional Switches                                               :slide:
  - Short and long switches
  - ~-v~ / ~--version~ - program version
  - ~-h~ / ~--help~ - help!
  - ~--~ - end of switches

There are MANY exceptions!!


*** Standard Input/Output/Error                                       :slide:

Most standard unix tools except to receive on stdin

After processing they put the changed text to stdout

Three streams. One for input, two for output.
- All programs have these.
- That doesn't mean they're always different!


*** Pipes                                                             :slide:

Shorthand for hooking the output of one program to the input of
another


*** The Environment                                                   :slide:

Convenient place to store information

**** Notes
Show the ~env~ command


** Jobs of a shell                                                    :slide:

High-level
- Expansions
- Argument splitting
- Setup environment
- Find/execute program
- Cleanup

*** Expansions                                                        :slide:

- file "globs"
- Special variables
  - Arguments, ~$0~-~$9~, ~$#~, ~$@~
  - Shell info, ~$$~ ~$!~ ~$?~
- Variables (so many possibilities!!)
  - Controlling variable expansion ${} etc.
- Sub-shells

**** Notes                                                             :note:

Do many demonstrations here!!

Have a script that demonstrates how argument expansion works


*** Arguments processing                                              :slide:

Who is familiar with processing command-line arguments?

All command line programs get arguments in this format:

A list of: ~program name arg1 arg2 arg3~

But how does it make that list?

**** Quoting                                                          :slide:

Preventing processing from occurring

- This can be tricky and subtle


*** Setup environment                                                 :slide:

- Input/output redirection


*** Program look-up/execution                                         :slide:

Search all paths in ~PATH~ variable, left-to-right order

- Overriding default paths


*** Exit Codes                                                        :slide:

0 => success
anything else => some kind of failure

- not always clear what the meaning is


*** Implicit State - this is not so important

**** Current User

- ~$UID~, ~$USER~


**** Current Directory

- ~$PWD~, ~pwd~, ~cd~


**** Environment Variables

- ~env~


** Actual Scripting                                                   :slide:

*** Loops and Conditionals                                            :slide:

These are similar to most programming languages but subtly different.


**** if                                                               :slide:

Runs a program, and checks the exit code

Show how ~[~ is a program also called ~test~


**** loops                                                            :slide:

- while: similar in concept to if
  - Show a standard counter style while loop
  - Show a more exotic bash type while loop (using which to figure out
    what path element an executable lives in)
- for: very different.  More reminiscent of python
  - does expansions, doesn't run commands

**** Notes                                                             :note:

For demos, consider using common files like /usr/dict and /etc/passwd


*** Cool examples

I have none...

Mine my github, the LDP pages, my provel scripts


*** Common Idioms

http://www.billharlan.com/papers/Bourne_shell_idioms.html


**** Argument processing


** Developing Shell Scripts

*** Man pages!!                                                       :slide:

Reading them is sort of an art


*** Incremental Build-up                                              :slide:

- Avoid permanent effects
- But learn how to setup test environments for doing destructive stuff

**** Notes                                                             :note:

Show the example of trying to figure out how many discrete shell
scripts


*** Guarding commands with echo                                       :slide:

Very simple, very effective


*** ~set -e~ and ~set -x~                                             :slide:

Really powerful options

**** -e "most important line in any bash script"

Default behavior


**** -x "almost as good a debugger"

Display everything!!


*** Mindset                                                           :slide:

Talk about the gitignore thing.  Upfront data structure creation
(process all .hignore files, then check each filename against all
patterns.  Obviously really bad in bash because no way to use a hash
table or something to speed up the checks

But what about flipping it around? Instead, enumerate all files, then
enumerate all files that match each pattern in a .hignore.  Then,
filter the list of those files by the ones that only appear once.


*** Dummy                                                             :slide:

#+OPTIONS: H:4 num:nil toc:nil tags:t

#+TAGS: slide(s) note(n)
