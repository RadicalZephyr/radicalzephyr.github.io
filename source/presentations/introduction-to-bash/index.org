---
layout: presentation
title: Introduction to Bash Scripting
---

Articulate a "floor" of what experience is required for this talk.
Particularly with concrete examples of what they should be able to do
(like you must have forked and merged with git)

- Think about motivating use cases

* A.K.A. - How To Use The Command-Line Like A Pro

** Basics

*** Unix Tools Philosophy

**** Standard Input/Output/Error

Three streams. One for input, two for output.
- All programs have these.
- That doesn't mean they're always different!


**** Pipes

Shorthand for hooking the output of one program to the input of
another


**** Everything is a (text) file

- As opposed to office suites
  - Binary file format (also proprietary)
  - Need specialized code to read/write in the correct format
  - Has "export" functions to transform it to different formats

-Talk about the programs as the objects of consideration ... ?


*** Library of Tools

Focus on a few at a time.  Empahasize incremental learning.  It's a
large toolbox and potentially overwhelming.  Take away is that adding
even one tool is a valuable outcome.


** Jobs of a shell

*** Arguments processing

Who is familiar with processing command-line arguments?

All command line programs get arguments in this format:

A list of: ~program name arg1 arg2 arg3~

But how does it make that list?


**** Quoting

Preventing processing from occurring

- This can be tricky and subtle


*** Program look-up/execution

Search all paths in ~PATH~ variable, left-to-right order

- Overriding default paths


*** Exit Codes

0 => success
anything else => some kind of failure

- not always clear what the meaning is


*** Expansions

- Special variables
  - Arguments, ~$0~-~$9~, ~$#~, ~$@~
  - Shell info, ~$$~ ~$?~
- Variables (so many possibilities!!)
- Sub-shells


*** Implicit State

**** Current User

- ~$UID~, ~$USER~


**** Current Directory

- ~$PWD~, ~pwd~, ~cd~


**** Environment Variables

- ~env~


** Actual Scripting

*** Loops and Conditionals

For demos, consider using common files like /usr/dict and /etc/passwd

*** Common Idioms

** Developing Shell Scripts

*** Incremental Build-up

**** Avoid permanent effects

**** But learn how to setup test environments for doing destructive

*** Guarding commands with echo

*** ~set -e~ and ~set -x~

*** Mindset

Talk about the gitignore thing.  Upfront data structure creation
(process all .hignore files, then check each filename against all
patterns.  Obviously really bad in bash because no way to use a hash
table or something to speed up the checks

But what about flipping it around? Instead, enumerate all files, then
enumerate all files that match each pattern in a .hignore.  Then,
filter the list of those files by the ones that only appear once.
