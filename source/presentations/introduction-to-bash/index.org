---
layout: presentation
title: Introduction to Bash Scripting
---

* A.K.A. - How To Use The Command-Line Like A Pro

** Basics

*** Unix Tools Philosophy

- The paradigm of this world

**** Everything is a (text) file

- Very file-oriented

- As opposed to office suites
  - Binary file format (also proprietary)
  - Need specialized code to read/write in the correct format
  - Has "export" functions to transform it to different formats


**** Library of Tools

Focus on a few at a time.  Empahasize incremental learning.  It's a
large toolbox and potentially overwhelming.  Take away is that adding
even one tool is a valuable outcome.

- show a web page here of list of many different unix tools


**** Arguments

- Two types
  - Switches (i.e. ~-c~ or ~--count~)
  - Other


**** Standard Input/Output/Error

Most standard unix tools except to receive on stdin

After processing they put the changed text to stdout

Three streams. One for input, two for output.
- All programs have these.
- That doesn't mean they're always different!


**** Pipes

Shorthand for hooking the output of one program to the input of
another


***** Conventional Switches

- Short and long switches
- ~-v~ / ~--version~ - program version
- ~-h~ / ~--help~ - help!
- ~--~ - end of switches

There are MANY exceptions!!


**** Environment

Show the ~env~ command


** Jobs of a shell

High-level
- Expansions
- Argument splitting
- Setup environment
- Find/execute program
- Cleanup

*** Expansions

- file "globs"
- Special variables
  - Arguments, ~$0~-~$9~, ~$#~, ~$@~
  - Shell info, ~$$~ ~$!~ ~$?~
- Variables (so many possibilities!!)
  - Controlling variable expansion ${} etc.
- Sub-shells

**** Notes

Do many demonstrations here!!

Have a script that demonstrates how argument expansion works


*** Arguments processing

Who is familiar with processing command-line arguments?

All command line programs get arguments in this format:

A list of: ~program name arg1 arg2 arg3~

But how does it make that list?

**** Quoting

Preventing processing from occurring

- This can be tricky and subtle



*** Setup environment

- Input/output redirection


*** Program look-up/execution

Search all paths in ~PATH~ variable, left-to-right order

- Overriding default paths


*** Exit Codes

0 => success
anything else => some kind of failure

- not always clear what the meaning is


*** Implicit State - this is not so important

**** Current User

- ~$UID~, ~$USER~


**** Current Directory

- ~$PWD~, ~pwd~, ~cd~


**** Environment Variables

- ~env~


** Actual Scripting

*** Loops and Conditionals

**** if

Runs a program, and checks the exit code

Show how ~[~ is a program also called ~test~


**** loops

- while: similar in concept to if
  - Show a standard counter style while loop
  - Show a more exotic bash type while loop (using which to figure out
    what path element an executable lives in)
- for: very different.  More reminiscent of python
  - does expansions, doesn't run commands

**** Notes

For demos, consider using common files like /usr/dict and /etc/passwd

*** Cool examples

I have none...

Mine my github, the LDP pages, my provel scripts

*** Common Idioms

http://www.billharlan.com/papers/Bourne_shell_idioms.html


**** Argument processing


** Developing Shell Scripts

*** Man pages!!

Reading them is sort of an art


*** Incremental Build-up

Show an example i.e. trying to extract info from /etc/passwd

**** Avoid permanent effects


**** But learn how to setup test environments for doing destructive


*** Guarding commands with echo

*** ~set -e~ and ~set -x~

Really powerful options

**** -e "most important line in any bash script"

Default behavior


**** -x "almost as good a debugger"

Display everything!!


*** Mindset

Talk about the gitignore thing.  Upfront data structure creation
(process all .hignore files, then check each filename against all
patterns.  Obviously really bad in bash because no way to use a hash
table or something to speed up the checks

But what about flipping it around? Instead, enumerate all files, then
enumerate all files that match each pattern in a .hignore.  Then,
filter the list of those files by the ones that only appear once.
